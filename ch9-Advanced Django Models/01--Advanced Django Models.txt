Advanced Django Models
---------------
https://djangobook.com/advanced-models/
---------------
In Chapter 4, we presented an introduction to Django’s database layer – how to define models and how to use the database API to create, retrieve, update and delete records.
In this chapter, we’ll introduce you to some more advanced features of this part of Django.
在`第4章`中，我们介绍了Django的`数据库层` - 如何`定义模型`以及如何使用数据库API来`创建`，`检索`，`更新`和`删除`记录。
在本章中，我们将向您介绍Django的这部分`更高级`的功能。

===============
Related Objects

Recall our book models from Chapter 4:
-----------------
from django.db import models

class Publisher(models.Model):
    name = models.CharField(max_length=30)
    address = models.CharField(max_length=50)
    city = models.CharField(max_length=60)
    state_province = models.CharField(max_length=30)
    country = models.CharField(max_length=50)
    website = models.URLField()

    def __str__(self):
        return self.name

class Author(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=40)
    email = models.EmailField()

    def __str__(self):
        return '%s %s' % (self.first_name, self.last_name)

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()

    def __str__(self):
        return self.title 
-----------------

As we explained in Chapter 4, accessing the value for a particular field on a database object is as straightforward as using an attribute. 
For example, to determine the `title` of the `book` with `ID 50`, we’d do the following:
-------------
>>> from mysite.books.models import Book
>>> b = Book.objects.get(id=50)
>>> b.title
'The Django Book'
-------------

But one thing we didn’t mention previously is that `related objects` – fields expressed as either a `ForeignKey` or `ManyToManyField` – act slightly differently.
但是我们之前没有提到的一件事是`相关对象' - 表示为`ForeignKey`或`ManyToManyField`的`字段`,这是略有不同。

==============================
### Accessing Foreign Key Values

When you access a field that’s a `ForeignKey`, you’ll get the related model object. For example:
--------------------
>>> b = Book.objects.get(id=50)
>>> b.publisher
<Publisher: Apress Publishing>
>>> b.publisher.website
'http://www.apress.com/'
-------------------
With `ForeignKey` fields, it works the other way, too, but it’s slightly different due to the non-symmetrical nature of the relationship. 
To get a list of books for a given `publisher`, use `publisher.book_set.all()`, like this:
有了`ForeignKey`字段，它也可以用其他方式工作，但由于关系的`非对称特性`，它稍有不同。
要获取给定`出版商`的一个`书籍`的`列表`，请使用`publisher.book_set.all（）`，如下所示：
-----------------
>>> p = Publisher.objects.get(name='Apress Publishing')
>>> p.book_set.all()
[<Book: The Django Book>, <Book: Dive Into Python>, ...]
-----------------
Behind the scenes, `book_set` is just a `QuerySet` (as covered in Chapter 4), and it can be filtered and sliced like any other `QuerySet`. For example:
------------------
>>> p = Publisher.objects.get(name='Apress Publishing')
>>> p.book_set.filter(title__icontains='django')
[<Book: The Django Book>, <Book: Pro Django>]
------------------
The attribute name `book_set` is generated by appending the lower case `model` name to `_set`.
`属性`名称-`book_set`,是通过将`小写`'model`名称,附加到`_set`来生成的。
======================
### Accessing Many-to-Many Values
访问多对多关键的值

`Many-to-many` values work like `foreign-key` values, except we deal with `QuerySet` values instead of `model` instances. 
For example, here’s how to view the `authors` for a `book`:
“多对多”值的工作方式类似于“外键”值，除了我们处理“QuerySet”值而不是“model”实例。
例如，以下是如何查看一个`book`的`authors`：
--------------
>>> b = Book.objects.get(id=50)
>>> b.authors.all()
[<Author: Adrian Holovaty>, <Author: Jacob Kaplan-Moss>]
>>> b.authors.filter(first_name='Adrian')
[<Author: Adrian Holovaty>]
>>> b.authors.filter(first_name='Adam')
[]
--------------
It works in reverse, too. To view all of the `books` for an `author`, use `author.book_set`, like this:
--------------
>>> a = Author.objects.get(first_name='Adrian',last_name='Holovaty')
>>> a.book_set.all()
[<Book: The Django Book>, <Book: Adrian's Other Book>]
---------------
Here, as with `ForeignKey` fields, the attribute name `book_set` is generated by appending the lower case `model` name to `_set`.
在这里，与'ForeignKey'字段一样，`属性`名称'book_set`是通过将小写`model`名称,附加到`_set`来生成的。
=======================
### Managers

In the statement `Book.objects.all()`, `objects` is a special attribute through which you query your database. 
In Chapter 4, we briefly identified this as the model’s `manager`. 
Now it’s time to dive a bit deeper into what `managers` are and how you can use them.
在语句`Book.objects.all（）`中，`objects`是查询数据库的一个特殊`属性`。
在`第4章`中，我们简要地将此视为模型的“manager”(`管理器`)。
现在是时候进一步深入了解`manager`(`管理器`)是什么以及如何使用它们。

In short, a model’s `manager` is an object through which Django models perform database queries. 
Each Django model has at least one `manager`, and you can create custom managers in order to customize database access. 
There are two reasons you might want to create a custom `manager`: to add extra manager methods, and/or to modify the initial `QuerySet` the manager returns.
简而言之，一个模型的`manager`是Django模型执行数据库查询的一个`对象`。
每个Django模型至少有一个`manager`，您可以创建`自定义管理器`来定制数据库访问。
有两个原因可能需要创建一个自定义`manager'：添加额外的`管理器方法`，和/或修改`管理器`返回的初始`QuerySet`。
===========================
## Adding Extra Manager Methods
添加额外的`管理器`方法

Adding extra manager methods is the preferred way to add table-level functionality to your models. 
(For `row-level` functionality – i.e., functions that act on a single instance of a model object – use model `methods`, which are explained later in this chapter.)
添加`额外的``管理器方法`,是将`表一级`的`功能`添加到你的`模型`的`首选方法`。
（对于“行一级”功能 - 即作用于模型对象的单个实例的`函数` - 使用模型“方法”，这将在本章后面解释）。

For example, let’s give our Book model a manager method `title_count()` that takes a `keyword` and returns the number of `books` that have a `title` containing that `keyword`.
(This example is slightly contrived, but it demonstrates how managers work.)
例如，让我们给`Book模型`添加一个`管理器方法`-`title_count()`，它需要一个`关键字`，并返回在`title`包含有该`关键字`的`books`的数量。
（这个例子稍有人为，但它展示了`管理者`的工作方式。）

-----------------
# models.py

from django.db import models

# ... Author and Publisher models here ...

class BookManager(models.Manager):
    def title_count(self, keyword):
        return self.filter(title__icontains=keyword).count()

class Book(models.Model):
    title = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher)
    publication_date = models.DateField()
    num_pages = models.IntegerField(blank=True, null=True)
    objects = BookManager()

    def __str__(self):
        return self.title Here are some notes about the code:
-----------------

-----------------
1.We’ve created a `BookManager class` that extends `django.db.models.Manager`. 
This has a single method, `title_count()`, which does the calculation. 
Note that the method uses `self.filter()`, where `self` refers to the `manager` itself.

1.我们创建了一个`BookManager类`来扩展`django.db.models.Manager`。
这有一个方法，`title_count（）`，它进行计算。
请注意，该方法使用`self.filter（）`，其中`self`指的是`manager`本身。


2.We’ve assigned `BookManager()` to the `objects` attribute on the `model`. 
This has the effect of replacing the “default” `manager` for the model, which is called `objects` and is automatically created if you don’t specify a custom `manager`. 
We call it `objects` rather than something else, so as to be consistent with automatically created `managers`.

2.我们已将`BookManager（）`分配给`model`上的`objects`属性。
这样做的效果是，替换模型的“默认”的`管理器`，称为“objects”，如果未指定自定义“管理器”，则会自动创建该`管理器`。
我们称之为“objects”而不是别的，以便与自动创建的“管理者”保持一致。
-----------------
With this manager in place, we can now do this:
----------------
>>> Book.objects.title_count('django')
4
>>> Book.objects.title_count('python')
18 
----------------
Obviously, this is just an example – if you typed this in at your interactive prompt, you will likely get different return values.
显然，这仅仅是一个例子 - 如果你在交互提示中输入了这个值，你可能会得到不同的返回值。

Why would we want to add a method such as `title_count()`? 
To encapsulate commonly executed queries so that we don’t have to duplicate code.
为什么我们要添加一个像`title_count（）`这样的`方法`？
封装通常执行的`查询`，以便我们不必`重复代码`。
==================
## Modifying Initial Manager QuerySets
修改初始`管理器`查询集

A `manager`’s base `QuerySet` returns all objects in the system. 
For example, `Book.objects.all() ` returns all books in the book database. 
You can override a `manager`’s base `QuerySet` by overriding the `Manager.get_queryset()` method. 
`get_queryset()` should return a `QuerySet` with the properties you require.

一个`manager`的基础`QuerySet`,返回系统中的`所有对象`。
例如，`Book.objects.all（）`返回`书籍数据库`中的所有`书籍`。
您可以通过覆盖`Manager.get_queryset（）`方法来覆盖`manager`的基础`QuerySet`。
`get_queryset（）`应该返回一个`QuerySet`,它里面包含了你所需要的属性。

For example, the following model has two `managers` – one that returns all objects, and one that returns only the books by `Roald Dahl`.
例如，下面的`模型`有两个`managers`--一个返回`所有对象`，一个只返回`Roald Dahl`的`书`。
------------------
from django.db import models

# First, define the Manager subclass.
class DahlBookManager(models.Manager):
    def get_queryset(self):
        return super(DahlBookManager, self).get_queryset().filter(author='Roald Dahl')

# Then hook it into the Book model explicitly.
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=50)
    # ...

    objects = models.Manager() # The default manager.
    dahl_objects = DahlBookManager() # The Dahl-specific manager.
---------------------

With this sample model, `Book.objects.all()` will return all books in the database, but `Book.dahl_objects.all()` will only return the ones written by `Roald Dahl`. 
Note that we explicitly set `objects` to a vanilla `Manager` instance, because if we hadn’t, the only available manager would be `dahl_objects`. 
Of course, because `get_queryset()` returns a `QuerySet` object, you can use `filter()`, `exclude()` and all the other QuerySet methods on it. 
So these statements are all legal:
在这个示例模型中，`Book.objects.all（）`将返回数据库中的所有书籍，但是`Book.dahl_objects.all（）`只会返回由'Roald Dahl`编写的书籍。
请注意，我们明确地将`ojbects`设置为一个vanilla`Manager`实例，因为如果我们没有，唯一可用的管理器将是`dahl_objects`。
当然，因为`get_queryset（）`返回一个`QuerySet`对象，所以你可以使用`filter（）`，`exclude（）`和所有其他的QuerySet方法。
所以，下列语句都是合法的：
--------------
Book.dahl_objects.all()
Book.dahl_objects.filter(title='Matilda')
Book.dahl_objects.count()
--------------

译者注：
作者的例子，有些不连贯，我在代码里面进行了修改。
最终效果如下：
----------------
>>> from books.models import Book
>>> Book.dahl_objects.all()
<QuerySet [<Book: 查理与巧克力工厂>, <Book: 飞天巨桃历险记>]>
>>> Book.dahl_objects.filter(title='查理')
<QuerySet []>
>>> Book.dahl_objects.filter(title='查理与巧克力工厂')
<QuerySet [<Book: 查理与巧克力工厂>]>
----------------
代码修改如下：
------------------------------
+class DahlBookManager(models.Manager):
+    def get_queryset(self):
+        try:
+            dahl = Author.objects.get(last_name='Dahl')
+        except Author.DoesNotExist:
+            return super(DahlBookManager,self).get_queryset().none() # return something like `<QuerySet>[]`
+        return super(DahlBookManager,self).get_queryset().filter(authors=dahl)
 class Book(models.Model):
     title = models.CharField(max_length=100,verbose_name='书名')
     authors = models.ManyToManyField(Author,verbose_name='作者')
@@ -47,6 +55,7 @@ class Book(models.Model):
     publication_date = models.DateField(blank=True, null=True,verbose_name='出版日期')
     num_pages = models.IntegerField(blank=True,null=True,verbose_name='页数')
     objects = BookManager()
+    dahl_objects = DahlBookManager() # The Dahl-sepcific manager
------------------------------

If you use custom `Manager` objects, take note that the first `Manager` Django encounters (in the order in which they’re defined in the model) has a special status. 
Django interprets this first `Manager` defined in a class as the “default” Manager, and several parts of Django (though not the `admin` application) will use that `Manager` exclusively for that model.

As a result, it’s often a good idea to be careful in your choice of `default manager`, in order to avoid a situation where overriding of `get_queryset()` results in an inability to retrieve objects you’d like to work with.
如果您使用自定义的`Manager`对象，请注意第Django遇到的第一个`Manager`（按照在模型中定义的顺序）具有特殊的`地位`。
Django将此类中定义的第一个`Manager`解释为“默认”管理器，并且Django的多个部分（尽管不是“admin”应用程序）将专门为该`模型`使用该'Manager'。
因此，为了避免重写`get_queryset（）`导致无法检索想要使用的对象的情况，谨慎选择`default manager`通常是一个好主意。
==============================
### Model methods
模型方法

Define custom methods on a model to add custom `row-level` functionality to your objects. 
Whereas `managers` are intended to do `table-wide` things, `model methods` should act on a particular model instance. 
This is a valuable technique for keeping business logic in one place – the `model`.
在一个模型上，定义`自定义方法`，为您的`对象`添加自定义的“行一级”的功能。
鉴于`管理器`是为了做'表一级'的事情，'模型方法'应该作用于一个特定的`模型实例`。
这是将`业务逻辑`保存在一个地方的一种有价值的`技术` - 保存在“模型”中。

An example is the easiest way to explain this. Here’s a model with a few custom methods:
一个例子是解释这个最简单的方法。以下是一些包含一些自定义方法的模型：
---------------------

m django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        # Returns the person's baby-boomer status.
        import datetime
        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    def _get_full_name(self):
        # Returns the person's full name."
        return '%s %s' % (self.first_name, self.last_name)
    full_name = property(_get_full_name)
--------------------------
baby boomer status
婴儿潮一代的状态

The model instance reference in `Appendix A` has a complete list of methods automatically given to each model. 
You can override most of these (see below) but there are a couple that you’ll almost always want to define:
在`附录A`中的`模型实例`引用中，有一个自动给出的模型的`完整列表`。
你可以`覆盖`其中的大部分（见下文），但有几个你几乎总是想定义：
----------------
++ __str__(). 
A Python “magic method” that returns a Unicode “representation” of any object. 
This is what Python and Django will use whenever a model instance needs to be coerced and displayed as a plain string. 
Most notably, this happens when you display an object in an interactive console or in the admin.
You’ll always want to define this method; 
the default isn’t very helpful at all.

一种Python“魔术方法”，它返回任何`对象`的Unicode“表示”。
这是Python和Django在一个模型`实例`需要强制显示为`纯字符串`时，将使用的内容。
最值得注意的是，当您在`交互式控制台`或`admin`中,显示`对象`时会发生这种情况。
你总是想要定义这个方法;
默认的，不是很有帮助。

++ get_absolute_url(). 
This tells Django how to calculate the URL for an object. 
Django uses this in its `admin interface`, and any time it needs to figure out a URL for an object. 
Any object that has a URL that uniquely identifies it should define this method.`
这告诉Django如何计算一个`对象`的URL。
Django在其“admin后台管理系统界面”中使用它，任何时候它都需要找出一个对象的一个`URL`。
----------------
=================================
### Overriding Predefined Model Methods
覆盖预定义的模型方法

There’s another set of model methods that encapsulate a bunch of database behavior that you’ll want to customize. 
In particular, you’ll often want to change the way `save()` and `delete()` work. 
You’re free to override these methods (and any other model method) to alter behavior. 
A classic use-case for overriding the built-in methods is if you want something to happen whenever you save an object. 
For example, (see `save()` for documentation of the parameters it accepts):
--------------------
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        do_something()
        super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
        do_something_else()
--------------------

You can also prevent saving:
-------------------
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, *args, **kwargs):
        if self.name == "Yoko Ono's blog":
            return # Yoko shall never have her own blog!
        else:
            super(Blog, self).save(*args, **kwargs) # Call the "real" save() method.
-------------------
It’s important to remember to call the `superclass` method – that’s that `super(Blog, self).save(*args, **kwargs)` business – to ensure that the object still gets saved into the database. 
If you forget to call the superclass method, the default behavior won’t happen and the database won’t get touched.
记得调用`superclass`方法是很重要的 - 那就是`super（Blog，self）.save（* args，** kwargs）`业务 - 确保这个`对象`仍然保存到｀数据库｀中。
如果您忘记调用`超类方法`，则`默认行为`将不会发生，并且`数据库`不会被`触及`。

It’s also important that you pass through the arguments that can be passed to the model method – that’s what the `*args, **kwargs` bit does. 
Django will, from time to time, extend the capabilities of built-in model methods, adding new arguments. 
If you use `*args, **kwargs` in your method definitions, you are guaranteed that your code will automatically support those arguments when they are added.

你传递给`模型方法`的`参数`也很重要 - 这就是`* args，** kwargs`位的作用。
Django将不时`扩展`内置模型方法的功能，增加新的参数。
如果您在方法定义中使用`* args，** kwargs`，则可以保证您的代码在添加时,自动支持这些参数。
===============================





========================


