Scaling Django
缩放Django

Now that you know how to get Django running on a single server, let’s look at how you can scale out a Django installation. This section walks through how a site might scale from a single server to a large-scale cluster that could serve millions of hits an hour. It’s important to note, however, that nearly every large site is large in different ways, so scaling is anything but a one-size-fits-all operation.
既然您已经知道如何让Django在`单个服务器`上运行，那么我们来看看如何扩展`Django安装`。
本节将介绍`站点`如何从`单个服务器`扩展到可支持数百万次点击的`大型群集`。
然而，需要注意的是，几乎每个大型网站都有不同的规模，因此`缩放`不过是一种`万能`的操作。

The following coverage should suffice to show the general principle, and whenever possible we’ll try to point out where different choices could be made. First off, we’ll make a pretty big assumption and exclusively talk about scaling under Apache and mod_python. Though we know of a number of successful medium- to large-scale FastCGI deployments, we’re much more familiar with Apache.
下面的报道应该足以说明一般原则，只要有可能，我们会试着指出可以做出不同选择的地方。
首先，我们将做一个很大的假设，并专门讨论`Apache`和`mod_python`下的扩展。
虽然我们知道许多成功的中型到大型`FastCGI`部署，但我们对`Apache`更加熟悉。

=============================
Running on a Single Server

Most sites start out running on a single server, with an architecture that looks something like Figure 13-1. However, as traffic increases you’ll quickly run into resource contention between the different pieces of software.
大多数网站开始运行在`单台`服务器上，架构如图13-1所示。
但是，随着流量的增加，您将很快陷入不同软件之间的`资源争夺`。

Database servers and Web servers love to have the entire server to themselves, so when run on the same server they often end up fighting over the same resources (RAM, CPU) that they’d prefer to monopolize. This is solved easily by moving the database server to a second machine.

`数据库服务器`和`Web服务器`喜欢将整个`服务器`放在自己的`服务器`上，因此当它们在`同一台`服务器上运行时，它们最终会争夺相同的资源（RAM，CPU），而他们更倾向于垄断它们。
通过将`数据库服务器`移动到`第二台机器`可以轻松解决这个问题。
==============================
Separating Out the Database Server
分离数据库服务器

As far as Django is concerned, the process of separating out the database server is extremely easy: you’ll simply need to change the DATABASE_HOST setting to the IP or DNS name of your database server. It’s probably a good idea to use the IP if at all possible, as relying on DNS for the connection between your Web server and database server isn’t recommended. With a separate database server,
our architecture now looks like Figure 13-2.
就Django而言，`分离``数据库服务器`的过程非常简单：
您只需将`DATABASE_HOST`设置,更改为`数据库服务器`的`IP`或`DNS`名称。
如果可能的话使用`IP`可能是一个`好主意`，因为`建议``不要`依赖`DNS`来连接`Web服务器`和`数据库服务器`。
使用单独的`数据库服务器`，
我们的架构现在看起来如图13-2所示。

Here we’re starting to move into what’s usually called n-tier architecture. Don’t be scared by the buzzword – it just refers to the fact that different tiers of the Web stack get separated out onto different physical machines.
在这里，我们开始进入通常称为`n层`体系结构。
不要被`流行语`所吓倒 - 它只是指`不同`层次的`Web堆栈`分离到不同的`物理`机器上。

At this point, if you anticipate ever needing to grow beyond a single database server, it’s probably a good idea to start thinking about connection pooling and/or database replication. Unfortunately, there’s not nearly enough space to do those topics justice in this book, so you’ll need to consult your database’s documentation and/or community for more information.
此时，如果您预计需要超越`单个``数据库服务器`，那么开始考虑`连接池`和/或`数据库复制`可能是个好主意。
不幸的是，本书中没有足够的空间来处理这些`主题`，因此您需要查阅`数据库`的`文档`和/或`社区`以获取更多信息。
===============================
Running A Separate Media Server
运行单独的媒体服务器

We still have a big problem left over from the single-server setup: the serving of media from the same box that handles dynamic content. Those two activities perform best under different circumstances, and by smashing them together on the same box you end up with neither performing particularly well.
我们仍然存在`单服务器``设置`遗留下来的大问题：
从处理`动态内容`的相同盒子中提供`媒体服务`。
这两种活动在`不同的情况下`表现`最佳`，并且在`同一个盒子`中将它们`砸在一起`，你的`表现`都`不会``特别出色`。

So the next step is to separate out the media – that is, anything not generated by a Django view – onto a dedicated server (see Figure 13-3).
因此，下一步是将`媒体`（即，不是由Django`视图`生成的`媒体`）分离出来到一台`专用服务器`上（请参见图13-3）。

Ideally, this media server should run a stripped-down Web server optimized for static media delivery. Nginx is the preferred option here, although lighttpd is another option, or a heavily stripped down Apache could work too. For sites heavy in static content (photos, videos, etc.), moving to a separate media server is doubly important and should likely be the first step in scaling up.
理想情况下，这个`媒体服务器`应该运行一个`优化的``静态媒体`传送的`简化Web服务器`。 
`Nginx`是这里的`首选`，尽管`lighttpd`是另一种选择，或者一个`严重剥离`的`Apache`也可以工作。
对于`静态`内容较多的网站（照片，视频等），转移到`单独的``媒体服务器`是非常重要的，应该可能是`扩大规模`的`第一步`。

This step can be slightly tricky, however. If your application involves file uploads, Django needs to be able to write uploaded media to the media server. If media lives on another server, you’ll need to arrange a way for that write to happen across the network.
然而，这一步可能有点棘手。
如果您的应用程序涉及`文件`上传，Django需要能够将`上传`的`媒体`写入`媒体服务器`。
如果`媒体`存在于`另一台``服务器`上，则需要为整个网络上的`写入`安排一种`方式`。
===============================
Implementing Load Balancing and Redundancy
实现`负载平衡`和`冗余`

At this point, we’ve broken things down as much as possible. This three-server setup should handle a very large amount of traffic – we served around 10 million hits a day from an architecture of this sort – so if you grow further, you’ll need to start adding redundancy.
在这一点上，我们已经尽可能地分解了一些东西。
这个`三台服务器`的`设置`应该处理大量的`流量` - 我们每天从这种`架构`提供约`1000万次`点击 - 所以如果您进一步发展，您需要开始添加`冗余`。

This is a good thing, actually. One glance at Figure 13-3 shows you that if even a single one of your three servers fails, you’ll bring down your entire site. So as you add redundant servers, not only do you increase capacity, but you also increase reliability. For the sake of this example, let’s assume that the Web server hits capacity first.
实际上，这是一件好事。从图13-3可以看出，如果`三台`服务器中只有`一台`服务器出现`故障`，则会导致整个`站点`停机。
因此，当您添加`冗余服务器`时，您不仅可以增加`容量`，还可以提高`可靠性`。
为了这个例子，我们假设`Web服务器`首先达到了`容量`。

It’s relatively easy to get multiple copies of a Django site running on different hardware – just copy all the code onto multiple machines, and start Apache on all of them. However, you’ll need another piece of software to distribute traffic over your multiple servers: a load balancer.
获取在不同`硬件`上运行的一个`Django站点`的`多个副本`相对比较`容易` - 只需将所有`代码`复制到`多台机器`上，然后在所有机器上启动`Apache`。
但是，您需要`另一个软件`来将`流量`分配到`多个服务器`上：`负载均衡器`。
You can buy expensive and proprietary hardware load balancers, but there are a few high-quality open source software load balancers out there. Apache’s mod_proxy is one option, but we’ve found Perlbal to be fantastic. It’s a load balancer and reverse proxy written by the same folks who wrote memcached (see Chapter 16).
您可以购买`昂贵`且专有的`硬件负载平衡器`，但是有一些`高质量`的`开源``软件负载平衡器`。 
`Apache`的`mod_proxy`是一种`选择`，但我们发现`Perlbal``非常棒`。
它是由编写`memcached`的`相同人员`编写的`负载均衡器`和`反向代理`（请参阅第16章）。

With the Web servers now clustered, our evolving architecture starts to look more complex, as shown in Figure 13-4.
随着`Web服务器`现在`集群化`，我们不断发展的`架构`开始变得更加`复杂`，如图13-4所示。

Notice that in the diagram the Web servers are referred to as a cluster to indicate that the number of servers is basically variable. Once you have a load balancer out front, you can easily add and remove back-end Web servers without a second of downtime.
请注意，在该图中，`Web服务器`被称为一个`群集`，以`指示``服务器`的`数量`基本上是`可变的`。
一旦您拥有`负载均衡器`，您就可以轻松`添加`和`删除``后端Web服务器`，而`无需``停机`。
===============================

===============================
Performance Tuning
性能调整

If you have huge amount of money, you can just keep throwing hardware at scaling problems. For the rest of us, though, performance tuning is a must.
如果你有大量的资金，你可以继续投放硬件来解决`扩展`问题。
但对于我们其他人来说，`性能调整`是`必须`的。

Incidentally, if anyone with monstrous gobs of cash is actually reading this book, please consider a substantial donation to the Django Foundation. They accept uncut diamonds and gold ingots, too.
Unfortunately, performance tuning is much more of an art than a science, and it is even more difficult to write about than scaling. If you’re serious about deploying a large-scale Django application, you should spend a great deal of time learning how to tune each piece of your stack.

顺便提一下，如果有人带着可怕的现金，实际上是在阅读本书，请考虑向Django基金会捐款。他们也接受未切割的`钻石`和`金锭`。
不幸的是，`性能调优`更像是一门`艺术`而不是一门`科学`，而`写作`比`调整`更困难。
如果您对部署大型Django应用程序非常`认真`，那么您应该`花费`大量时间学习如何`调整`您的每个`堆栈`。

The following sections, though, present a few Django-specific tuning tips we’ve discovered over the years.
但是，以下部分介绍了多年来我们发现的一些Django特定调优技巧。
================================
There’s No Such Thing as Too Much RAM
没有`内存太多`的这么一说

Even the really expensive RAM is relatively affordable these days. Buy as much RAM as you can possibly afford, and then buy a little bit more. Faster processors won’t improve performance all that much;
most Web servers spend up to 90% of their time waiting on disk I/O. As soon as you start swapping, performance will just die. Faster disks might help slightly, but they’re much more expensive than RAM, such that it doesn’t really matter.

即使是非常昂贵的`RAM`现在也相对`便宜`。购买`尽可能多`的RAM，然后`购买``更多`。`更快`的`处理器`不会`提高性能`;
大多数`Web服务器`花费高达`90％`的`时间``等待``磁盘I/O`。
只要你开始`交换`，`性能`就会`消失`。
更快的`磁盘`可能会有所帮助，但是它们比`RAM`更`昂贵`，所以它并`不重要`。

If you have multiple servers, the first place to put your RAM is in the database server. If you can afford it, get enough RAM to fit your entire database into memory. This shouldn’t be too hard; we’ve developed a site with more than half a million newspaper articles, and it took under 2GB of space.
如果你有`多个服务器`，放置你的`RAM`的第一个地方,是在`数据库服务器`中。
如果你能`负担得起`，获得`足够`的`内存`以适合你的`整个数据库`。
这不应该太难;我们已经开发了一个有`50多万份``报纸文章`的网站，并且它占用了`2GB`的空间。

Next, max out the RAM on your Web server. The ideal situation is one where neither server swaps – ever. If you get to that point, you should be able to withstand most normal traffic.
接下来，在`Web服务器`上`最大化``RAM`。
理想的情况是，`服务器`不需要`swap`-交换。
如果你达到这一点，你应该能够`承受`最正常的`交通流量`。
====================================
Turn Off Keep-Alive
关闭Keep-Alive

Keep-Alive is a feature of HTTP that allows multiple HTTP requests to be served over a single TCP connection, avoiding the TCP setup/teardown overhead. This looks good at first glance, but it can kill the performance of a Django site. If you’re properly serving media from a separate server, each user browsing your site will only request a page from your Django server every ten seconds or so. This leaves HTTP servers waiting around for the next keep-alive request, and an idle HTTP server just consumes RAM that an active one should be using.
`Keep-Alive`是`HTTP`的一项`功能`，它允许通过`单个TCP连接`提供`多个HTTP请求`，避免`TCP设置/拆卸``开销`。
乍一看,这看起来不错，但它可能会导致`Django站点`的性能下降。
如果您正在从一台`单独的``服务器`正常提供`媒体服务`，则每个`浏览`您网站的`用户`将只会`每隔十秒`左右从您的`Django服务器`请求一个`页面`。
这使`HTTP服务器`等待下一个`保持活动`的`请求`，而一个`空闲`的`HTTP服务器`只消耗一个`活动的`应该使用的`RAM`。
=====================================
Use Memcached
使用Memcached

Although Django supports a number of different cache back-ends, none of them even come close to being as fast as Memcached. If you have a high-traffic site, don’t even bother with the other backends – go straight to Memcached.
尽管Django支持许多不同的`缓存后端`，但它们都没有像`Memcached`那么快。
如果您拥有`高流量`的`网站`，请不要打扰`其他后端` - 直接访问`Memcached`。
=====================================
Use Memcached Often

Of course, selecting memcached does you no good if you don’t actually use it. Chapter 16 is your best friend here: learn how to use Django’s cache framework, and use it everywhere possible.
Aggressive, pre-emptive caching is usually the only thing that will keep a site up under major traffic.
当然，如果你没有真正使用它，选择`memcached`对你来说就`不好`。
《第16章》是你最好的`朋友`：`学习`如何使用`Django`的`缓存框架`（`cache framework`），并在任何可能的地方使用`它`。
积极的,先发制人的`高速缓存`通常是`能够`在`大的流量`下`保持`一个网站稳定的唯一的东西。
=====================================
Join the Conversation
加入对话

Each piece of the Django stack – from Linux to Apache to PostgreSQL or MySQL – has an awesome community behind it. If you really want to get that last 1% out of your servers, join the open source communities behind your software and ask for help. Most free-software community members will be happy to help. And also be sure to join the Django community – an incredibly active, growing group of Django developers. Our community has a huge amount of collective experience to offer.
每个`Django堆栈` - 从`Linux`到`Apache`到`PostgreSQL`或`MySQL`  - 都有一个非常棒的社区。
如果您真的想从您的`服务器`中获得最后`1％`，请加入`软件`背后的`开源社区`并寻求帮助。
大多数免费软件社区成员都乐意提供帮助。
同时也一定要加入`Django社区` - 一个令人`难以置信`的`积极`的，不断增长的`Django开发者群体`。
我们的社区拥有丰富的集体经验。
=====================================

